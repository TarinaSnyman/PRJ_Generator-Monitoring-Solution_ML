<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Anomaly & Failure Probability Dashboard</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
input, button { margin: 5px 0; padding: 5px; }
pre { background: #f4f4f4; padding: 10px; border: 1px solid #ddd; max-height: 300px; overflow:auto; }
.alert { font-weight: bold; padding: 10px; margin: 10px 0; border-radius: 4px; }
.ok { background: #d4edda; color: #155724; }
.error { background: #f8d7da; color: #721c24; }
</style>
</head>
<body>
<h2>Generator Monitoring Dashboard</h2>

<label>API Key:</label>
<input type="text" id="apiKey" value="key123456">

<h3>1. Health Check</h3>
<button onclick="callHealth()">Check Health</button>
<pre id="healthResult"></pre>

<h3>2. DB Connection Test</h3>
<button onclick="callDBConnection()">Test DB Connection</button>
<pre id="dbResult"></pre>

<h3>3. Fetch Raw Data</h3>
<label>AIR ID:</label>
<input type="text" id="fetchAir" value="Epi">
<button onclick="callFetchData()">Fetch Data</button>
<pre id="fetchResult"></pre>

<h3>4. Feature Engineering Test</h3>
<label>AIR ID:</label>
<input type="text" id="featureAir" value="Epi">
<button onclick="callFeatures()">Test Features</button>
<pre id="featureResult"></pre>

<h3>5. Anomaly Detection (XGBoost)</h3>
<label>AIR ID:</label>
<input type="text" id="anomalyAir" value="Epi">
<button onclick="updateAnomaly()">Predict Anomaly</button>
<div id="anomalyAlert"></div>
<pre id="anomalyResult"></pre>

<h3>6. Failure Probability Prediction (CNN-LSTM)</h3>
<label>AIR ID:</label>
<input type="text" id="rulAir" value="Epi">
<button onclick="updateRUL()">Predict Failure Probabilities</button>
<div id="rulAlert"></div>
<pre id="rulResult"></pre>

<script>
const serverUrl = "https://euna-luteotropic-casie.ngrok-free.dev"; // ngrok URL that tunnels to api on server

function getHeaders() {
    return {
        "x-api-key": document.getElementById("apiKey").value,
        "ngrok-skip-browser-warning": "true"
    };
}

function showAlert(id, message, isError=false) {
    const div = document.getElementById(id);
    div.className = "alert " + (isError ? "error" : "ok");
    div.innerText = message;
}

// Unified fetch with console logging
async function safeFetch(endpoint) {
    const url = `${serverUrl}${endpoint}`;
    const headers = getHeaders();
    console.log("Fetching:", url);
    console.log("Headers:", headers);
    try {
        const res = await fetch(url, { headers });
        console.log("Raw response:", res);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        console.log("Parsed JSON:", data);
        return data;
    } catch (err) {
        console.error("Fetch error:", err);
        throw err;
    }
}

// Health check
async function callHealth() {
    try {
        const data = await safeFetch("/health");
        document.getElementById("healthResult").innerText = JSON.stringify(data, null, 2);
        showAlert("healthResult", "‚úÖ Server healthy, anomaly model loaded: " + data.anomaly_model_loaded);
    } catch {
        showAlert("healthResult", "‚ùå Error fetching health", true);
    }
}

// DB connection
async function callDBConnection() {
    try {
        const data = await safeFetch("/test_db_connection");
        if (data.status === "ok") {
            document.getElementById("dbResult").innerText = `‚úÖ DB connected! Rows returned: ${data.rows_returned}`;
        } else {
            document.getElementById("dbResult").innerText = `‚ùå DB connection failed: ${data.error}`;
        }
    } catch {
        document.getElementById("dbResult").innerText = "‚ùå Error connecting to DB";
    }
}

// Fetch raw data
async function callFetchData() {
    const air = document.getElementById("fetchAir").value;
    try {
        const data = await safeFetch(`/fetch_data?air_id=${air}`);
        document.getElementById("fetchResult").innerText = JSON.stringify(data, null, 2);
    } catch {
        document.getElementById("fetchResult").innerText = "‚ùå Error fetching data";
    }
}

// Feature engineering test
async function callFeatures() {
    const air = document.getElementById("featureAir").value;
    try {
        const data = await safeFetch(`/test_features?air_id=${air}`);
        if (data.detail) {
            document.getElementById("featureResult").innerText = `‚ùå ${data.detail}`;
        } else {
            document.getElementById("featureResult").innerText = JSON.stringify(data, null, 2);
        }
    } catch {
        document.getElementById("featureResult").innerText = "‚ùå Error during feature engineering";
    }
}

// Anomaly prediction
async function updateAnomaly() {
    const air = document.getElementById("anomalyAir").value;
    try {
        const data = await safeFetch(`/predict_anomaly?air_id=${air}`);
        if (data.detail) {
            document.getElementById("anomalyResult").innerText = `‚ùå ${data.detail}`;
            showAlert("anomalyAlert", "‚ùå Error", true);
        } else if (data.anomaly === null) {
            document.getElementById("anomalyResult").innerText = data.message;
            showAlert("anomalyAlert", "‚ö†Ô∏è No new data", true);
        } else {
            document.getElementById("anomalyResult").innerText = JSON.stringify(data, null, 2);
            if (data.anomaly === 1) {
                showAlert("anomalyAlert", "üö® Anomaly detected! Probability: " + (data.probability*100).toFixed(2) + "%");
            } else {
                showAlert("anomalyAlert", "‚úÖ No anomaly detected. Probability: " + (data.probability*100).toFixed(2) + "%");
            }
        }
    } catch {
        document.getElementById("anomalyResult").innerText = "‚ùå Error fetching anomaly";
    }
}

// Failure probability prediction
async function updateRUL() {
    const air = document.getElementById("rulAir").value;
    try {
        const data = await safeFetch(`/predict_cnn_lstm?air_id=${air}`);
        if (data.detail) {
            document.getElementById("rulResult").innerText = `‚ùå ${data.detail}`;
            showAlert("rulAlert", "‚ùå Error", true);
        } else if (data.failure_probabilities) {
            const probs = data.failure_probabilities;
            let output = `Failure probabilities for AIR ${data.air_id}:\n`;
            output += `1 hour ahead:  ${(probs["1_hour"]*100).toFixed(2)} %\n`;
            output += `2 hours ahead: ${(probs["2_hours"]*100).toFixed(2)} %\n`;
            output += `4 hours ahead: ${(probs["4_hours"]*100).toFixed(2)} %\n`;
            output += `6 hours ahead: ${(probs["6_hours"]*100).toFixed(2)} %\n`;
            document.getElementById("rulResult").innerText = output;

            const maxProb = Math.max(probs["1_hour"], probs["2_hours"], probs["4_hours"], probs["6_hours"]);
            if (maxProb > 0.5) {
                showAlert("rulAlert", `üö® High failure risk! Max probability: ${(maxProb*100).toFixed(1)}%`);
            } else {
                showAlert("rulAlert", "‚úÖ Failure risk low");
            }
        } else {
            document.getElementById("rulResult").innerText = "No data returned";
            showAlert("rulAlert", "‚ö†Ô∏è No data", true);
        }
    } catch {
        document.getElementById("rulResult").innerText = "‚ùå Error fetching failure probabilities";
        showAlert("rulAlert", "‚ùå Error", true);
    }
}

</script>
</body>
</html>
